DMRG Linear-Response Theory Code for Excited State: N. Nakatani wrote

this is a chart of implementation:

(1) modules to be changed
 + Evaluation of < 0 | H | I > cannot be exploited transpose symmetry, such like 'Des_i = (Cre_i)^(T)'
 - opxop and op_components are hacked?

 + 1-st order wavefunctions, rotation matrices, and renormalized operators are rotated by Ritz vector through sweeping
 - do_one may contains control function to perform Krylov solver

 + To compute 1-st order rotation matrices, Jon's code might be re-usable

 + Setting initial guesses for excited states

 + Gauge-transfer in 1-st order wavefunction

 + Input specifications

(2) storages
 + All addtional storages are
 - 1-st order wavefunctions, rotation matrices, and renormalized operators (transposed operators, too)
 - Hamiltonian and overlap matrices spanned by Krylov trial vectors
 - Ritz vectors
 - Residual norms

(*) concerns
 + pseudo-code
 1 suppose, one-site ground state wavefunction is computed in usual way.
 2 run program again to perform lrt calculation.
 3 call genblock? to fix the 0-th gauge. set guess wavefunctions.
 4 solve generalized-eigenvalue problem to get Ritz vector.
 5 rotate storages, compute contribution for each site, solve correction equation, and compute 1-st order rotation matrix.
 6 transfer gauge to next site = similar to compute guess wavefunction.
 7 check convergence, and continue 4-6 until convergence.

 + new class?
 - SpinBlockDerived : public SpinBlock
   may contain i-th root info (to use save & load), and derived operators (explicitly compute transposed operators, too).

 + new function
 - rotate storages by Ritz vector
   load previous storages to rotate and save; O(M^2 N^2 k^2) for CPU, O(M^2 N k^2) for MEM

In 'Sweep***::do_one'

{
  Matrix & subspace_h;
  Matrix & subspace_s;

  int & nroots; // # of roots to be solved
  int & mroots; // # of trial vectors in Krylov subspace
  int & lroots; // # of trial vectors to be updated

  std::vector<double> R_norm(nroots, 0.0);
  Matrix alpha;

  solve_generalized_eigenvalue_problem(subspace_h, subspace_s, eigenvalue, alpha);

  subspace_h.resize(mroots+lroots, mroots+lroots, 0.0);
  subspace_s.resize(mroots+lroots, mroots+lroots, 0.0);

  *** DO SWEEP ***

  int n_conv_roots = 1;
  for(; n_conv_roots < nroots; ++n_conv_roots) {
    if(R_norm[n_conv_roots] >= tolerance) break;
  }

  return n_conv_roots;
}



Initialization / Create Guesses --- hack SweepGenblock and fullrestart?
 + fix gauge of 0-th wavefunctions
   - can be done in fullrestart?
 + compute Krylov trial vectors (nroots) for initial guess
   - can be shared with LRT main routine?
 + compute contributions to subspace H and S
   - this is shared with LRT main routine
 + compute 1-st rotation matrices and renormalize
   - this is shared with LRT main routine

1-st order renormalized operator ( Operator_deriv ? )
 + change 'opTypes' (defined in BaseOperator.h) will be hacked
 + in Jon's code, '***_DERIV' components are added, e.g. CRE_DES_DERIV etc.
   however, LRT needs to store OPS[0, I] and OPS[I, 0] for each operator component
 - thus, storage type 'map<opTypes, shared_ptr<Op_components> >'

   typedef uinsigned int opTypes;

   enum OP_COMPONENT_TYPE
   {
     HAM             = 0x01000000,
     CRE             = 0x02000000,
     CRE_CRE_DESCOMP = 0x03000000,
     CRE_CRE         = 0x04000000,
     DES_DESCOMP     = 0x05000000,
     CRE_DES         = 0x06000000,
     CRE_DESCOMP     = 0x07000000,

     OP_TYPE_MASK    = 0xff000000,
     BRASTAT_MASK    = 0x00fff000,
     KETSTAT_MASK    = 0x00000fff,
     GENERIC_MASK    = 0x00ffffff
   };

   first  12 bits: describe state # of ket (up to 4095)
   second 12 bits: describe state # of bra (up to 4095)
   third   8 bits: describe operator type

   if another operator type such like Sz, other than LRT calculation,
   upper 8 bits must set to be 0x00****** to use lower 24 bits to define generic operator

####################################################################################################
	Pseudo Code for implementation in BLOCK code
####################################################################################################

+ initialize storages

+ Davidson iteration
| + solve generalized eigenvalue problem: H*U = E*S*U
|   - save eigen values E
|   - state rotation matrix U
|   - resize H (mroots + kroots, mroots + kroots) = 0
|   - resize S (mroots + kroots, mroots + kroots) = 0
|
| - resize residual norm Q (nroots) = 0
|
| + loop over sites (sweeping)
| | + rotate state vectors
| |   - rotate 1-st order right rotate matrix R by U
| |   - if ( block_iter == 0 )
| |     rotate wavefunction W by U
| |   - else
| |     transform gauge condition (hack guess wavefunction)
| |
| |   - rotate environment block B by U
| |
| | + solve correction equation
| |   - VX(J) = A(00) B(00) W(J) + A(00)^(T) B(00)^(T) W(J)
| |           + A(0J) B(00) W(0) + A(J0)^(T) B(00)^(T) W(0)
| |           + A(00) B(0J) W(0) + A(00)^(T) B(0J)^(T) W(0)
| |
| |   - compute error vector, add norm to Q(iroot) { iroot = 1...nroots }
| |     if (iroot > nroots - kroots)
| |     - orthogonalize to W(0), add to W(mroots + iroot)
| |
| | + project out 0-th system space from wavefunction W(iroot)
| |   and store X(iroot) intermediately { iroot = 1...mroots+kroots }
| |   - if ( block_iter < N )
| |     X(iroot) = (1 - A(0) A(0)') W(iroot)
| |   - else
| |     X(iroot) = W(iroot)
| |
| | + compute elements of H and S { I > J = 1...mroots+kroots }
| |   - VX(J)  = A(00) B(00) X(J) + A(00)^(T) B(00)^(T) X(J) // reuse multiply_h
| |
| |   - V0(J)  = A(0J) B(00) X(0) + A(J0)^(T) B(00)^(T) X(0)
| |
| |   - H(II) += X(I) VX(I) + X(I) V0(I) * 2
| |   - H(IJ) += X(I) VX(J) + X(I) V0(J) + X(J) V0(I)
| |
| |   - S(II) += X(I) X(I)
| |   - S(IJ) += X(I) X(J)
| |
| | + if ( block_iter < N )
| |   - compute 1-st order left rotate matrices L(iroot) { iroot = 1...mroots+kroots }
| |
| | + renormalize 1-st order operators / transposed operators are not computed
| |   - A(I0)' = L(0) A(I0) L(0) + L(I) A(00) L(0)
| |
| |   - A(0I)' = L(0) A(0I) L(0) + L(0) A(00) L(I)
| |
| | - save block state
| |
| + end sweep
|
| - check convergence by Q and set kroots = # of roots not converged
|
+ end iteration


lrt_BaseOperator / done

lrt_davidson / done

lrt_renormalise / done

lrt_rotationmat / done

lrt_solver / done

lrt_spinblock / done

lrt_sweep / done

lrt_transform_ops / done

lrt_transform_gauge / done

lrt_state_rotation / done


====================================================================================================
Faster Algorithm:
====================================================================================================

+ sweep 1-st
- L-MPS: self-rot / calc & save { 1...L }
- R-MPS: rot { 1...M-1 }
- SGVAI: rot { 1...M-1 } / calc { M...L-1 } / save fwd { 1...L-1 } / dot_with_sys = true
- SGVA0: rot { 1...M-1 } / calc { M...L-1 } / save fwd { 1...L-1 } / dot_with_sys = true
- SGVB0: ---
- SGVTI: trans & rot { 1...M-1 } / save fwd { 1...M-1 }

+ sweep 2-nd
- L-MPS: ---
- R-MPS: self-rot / calc & save { 1...L-1 }
- SGVAI: ---
- SGVA0: ---
- SGVB0: rot { 1...M-1 } / calc { M...L-1 } / save bwd { 1...L-1 }
- SGVTI: trans { 1...M-1 } / calc { M...L-1 } / save bwd { 1...L-1 }




